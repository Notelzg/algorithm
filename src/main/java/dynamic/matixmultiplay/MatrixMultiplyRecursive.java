package dynamic.matixmultiplay;

/**
 * 矩阵链乘法
 * 获取代价最小的矩阵链，通姑婆给矩阵链添加括号，修改乘法的顺序
 * 1， 最优子结构特征刻画
 * 矩阵链肯定存在一个分割点k，把矩阵链分为两个子部分，但是两个子部分的
 * 最优解，不代表是最优解，以为矩阵相乘的是 c=A(100,50) B(50,70)
 * 相乘的总次数是，100*50*70, 还需要计算一下才行, 从中选出最小的值才行
 * 但是整体来看，首先要拆分为两个子结构，其次要分别计算子结构
 * 最后根据子结构来计算最优解。子结构不存在相互影响的情况，属于独立的
 * 而且子结构，还可以拆解为更小的子结构进行计算，当只有一个矩阵时，结果是确定的
 * <p>
 * 如果n个矩阵总共有 n-1分割点，每个分割点存在两种情况，而且互相独立
 * 所以所有的情况是 2^(n-1)，即时间复杂度是 O(2^(n-1)), 是n的指数级别
 * <p>
 * 2， 递归式
 * p[n] 标识矩阵的长和宽的，标识矩阵链 100，50，70 标识，两个矩阵 A[100,50] B[50,70]
 * 这个是因为矩阵的特性，如果矩阵相乘，必须要列和行一样才行
 * 所以如果 分割点为下标k，分割后的矩阵总的计算次数为 t = p[0]*p[k]*p[n]
 * 如果分割点为k则，矩阵分为两部分
 * p[0,1,2,...k] 根据矩阵乘法的特性，最后矩阵的大小是 =p[0,k]
 * p[k+1, K+2,...n]，同上矩阵大小为： p[k+1,n]
 * p[0,k]*p[k+1,n] = p[1]*p[k]*p[n]
 * 所以递归式为
 * i 标识矩阵链开始，j 标识矩阵链结束， 只有i<j 的时候才有意义
 * 当i == j 的时候，标识一个矩阵，这个时候乘积的个数就是0
 * // 递归结束条件
 * expect[i,j] = 0. i == j
 * expect[i,j] = Math.min([p[i][k][j]+recursive(p[i,k])+ recursive(p[k+1, j])), k 从1，到 n-1 ,i<j 的时候
 * <p>
 * 3， 计算值计算
 * 先用递归求解，再进行优化，比较简单
 * 4， 构造最优解
 * 得到最小乘积次数之后，还需要把括号之后的矩阵输出来，才行
 * cuts 记录了每个子问题的分割点，也就是添加括号的地方
 * 需要添加括号把分割点两边的子问题括起来，同时把整个问题括起来
 * 所以使用递归的方式处理
 * cuts[i][j] > 0 ,分别给左边加两个开始括号 ((
 * 中间分割点，加两个括号，)(
 * 最后添加 ））
 * 输出括号化的矩阵
 *
 */
public class MatrixMultiplyRecursive {

  /**
   * @param p 矩阵链数组，长度 n+1, p[0] 标识第一个矩阵的行，p[1] 第一个矩阵列， p[n] 最后一个矩阵的列
   * @param i 矩阵链开始下标, 从1开始, 如果从0开始，就不是矩阵了
   * @param j 矩阵链结束下标
   * @return
   */
  public static int solution(int[] p, int i, int j) {
    // 递归结束条件
    if (i == j) {
      return 0;
    }
    int min = Integer.MAX_VALUE;
    // k是分割点，所以k应该从i开始，i从1开始，已经标识的是列，不是行了，代表一个分割点
    // k只能从i开始，如果从i+1开始，无法处理只有两个矩阵的情况，
    // k不能等于j，如果等于j，则会导致无限循环，因为等于k的时候，相当于重新计算最优解
    for (int k = i; k < j; k++) {
      // p[i-1] 是i个矩阵的行
      int expect = p[i-1] * p[k] * p[j] + solution(p, i, k) + solution(p, k + 1, j);
      if (min > expect) {
        min = expect;
      }
    }
    return min;
  }
}
