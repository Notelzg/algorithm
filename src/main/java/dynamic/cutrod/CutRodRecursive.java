package dynamic.cutrod;

/**
 * 钢条切割问题
 * 描述，一段钢条，可以切成不同的长度，不同的长度价格不一样
 * 如何切割，才能达到最高价格，也就是最优解。
 * p[0,n]
 * 1， 构造最优子结构
 * 钢条肯定存在一个切割点，k，通过k把钢条分成两部分，两部分都是最优子结构
 * 两部分加起来就是整个钢条的最优解。可以把大的问题拆成子问题求解，而且子问题
 * 互不影响，子问题还存在重叠的问题。
 * k可以是0，也就是左边是0，右边是整个钢条。
 * 2， 递归公式
 * p = 0， n=0时，是递归公式的退出
 * p = Math.max(p[k]+p[n-k]), n 从0，到n
 * 3， 计算最优解的值
 * 递归构造，比较方便，递归完成之后，可以进行优化，或者转为自底向上的非递归方法
 * 因为递归是有开销的，当前哪个方法更好，取决于不同的场景
 * 4， 构造最优解
 *  计算出最高价格之后呢，需要把切割方案输出一下，输出最优解的切割点
 *  这里需要记录最大值，把所有的最大值的下标记录下来，就是相应的切割点
 */
public class CutRodRecursive {
  /**
   * 暴力解法
   * 时间复杂度 O(x^(n-1)
   * 因为，钢条最小单位，存在两个情况，切割或者不切割，切割点总共有n-1个
   * 而且各个切割点是独立时间，所以总的事件空间是就是 2*2**n-1
   * 便利所有的情况，找出最大值。

   * 基础递归版本
   * 自顶向下
   * 时间复杂度  for循环每层都需要n次，所以最大是O(2^(n-1))
   * 空间复杂度 O(1)
   * 问题，就是重复的字问题，重复计算导致时间复杂度很大,由于字问题是独立的
   * 所以相同长度的子问题，也会重复计算，如果相同问题不再重复计算，那整个
   * 时间复杂度变成了多少呢？n^2。
   *
   * @param n  钢条的长度
   * @param prices 长度为下标的钢条的价格，prices的长度是n+1, 下标
   *               因为需要prices[n] 标识长度为n的钢条的价格
   *               prices[0] 返回0，标识长度为0的钢条价格是0.
   *               prices[1] 返回1，标识长度为1的钢条价格是1.
   * @return
   */
  public static int solution(int n, int[] prices) {
    if (n == 0) {
      return 0;
    }
    int priceMax = 0;
    // 这里从1开始，如果从0开始，就需要计算solutionRecursive(n),
    // 这个问题我们是通过这个for循环，拆为子问题进行计算的，如果从0开始，会造成无限循环
    for (int k = 1; k <= n; k++) {
        int price =  prices[k] + solution(n - k, prices);
        if (priceMax < price) {
          priceMax = price;
       }
    }
    return priceMax;
  }
}
